@using System.Collections.Concurrent
@using Common.DTOs
@using Microsoft.AspNetCore.SignalR.Client
@using StreamHub.Services
@inject BlazorSignalRService SignalRService
@inject IJSRuntime JsRuntime

<!-- Pause/Unpause Button -->
<button
    @onclick="TogglePauseRendering"
    class="px-4 py-2 rounded 
        @(_pauseRendering ? "bg-red-500 text-white hover:bg-red-700" : "bg-green-500 text-white hover:bg-green-700")">
    @(_pauseRendering ? "Resume Log Updates" : "Pause Log Updates")
</button>

<!-- Download Logs Button -->
<button
    @onclick="DownloadLogs"
    class="px-4 py-2 rounded bg-indigo-500 text-white hover:bg-indigo-700">
    Download Logs
</button>
<div class="w-60">
    
</div>
@if (LogMessages.Any())
{
    <div style="height: 200px; overflow-y: auto; resize: vertical;" class="w-100">
        <Virtualize Items="LogMessages.TakeLast(100).Reverse().ToList()" Context="logMessage" ItemSize="10">
            <div class="log-entry">
                <div class="@GetLogLevelClass(logMessage.LogLevel)">
                    @if (IsOutOfSequence(logMessage))
                    {
                    <span class="text-warning">&#9888;</span>
                    }
                    @logMessage.LogSequenceNumber: @logMessage.Timestamp : @logMessage.LogLevel : @logMessage.Message
                </div>
            </div>
        </Virtualize>
    </div>
}
else
{
    <p>Ingen logbeskeder.</p>
}

@code {
    [Parameter] public ConcurrentQueue<LogEntry> LogMessages { get; set; } = new();
    [Parameter] public required string WorkerId { get; init; }
    [Parameter] public required string EngineId { get; init; }

    private bool _isSubscribed = false;
    private bool _pauseRendering = false;
    private bool _forceRender = true;

    private int? _previousSequenceNumber = null;

    private bool IsOutOfSequence(LogEntry logMessage)
    {
        if (_previousSequenceNumber == null)
        {
            _previousSequenceNumber = logMessage.LogSequenceNumber;
            return false;
        }
        if (logMessage.LogSequenceNumber != _previousSequenceNumber - 1)
        {
            _previousSequenceNumber = logMessage.LogSequenceNumber; // Opdater for næste tjek
            return true; // Ude af rækkefølge
        }

        _previousSequenceNumber = logMessage.LogSequenceNumber; // Opdater for næste tjek
        return false; // Sekvensen er i orden
    }
    

    protected override async Task OnInitializedAsync()
    {
        await SubscribeToLogs();

        SignalRService.HubConnection.On<LogEntry>("ReceiveLog", async logLine =>
        {
            if (WorkerId == logLine.WorkerId)
            {
                await InvokeAsync(StateHasChanged);
            }
        });
    }
    
    private string GetLogLevelClass(LogLevel logLevel)
    {
        return logLevel switch
        {
            LogLevel.Warning => "bg-yellow-900 text-yellow-200",
            LogLevel.Error => "bg-red-900 text-red-200",
            LogLevel.Critical => "bg-red-900 text-red-200 font-bold",
            _ => "", // Standardfarve for Information eller lavere
        };
    }

    private async Task TogglePauseRendering()
    {
        _pauseRendering = !_pauseRendering;

        if (!_pauseRendering)
        {
            await SubscribeToLogs();
        }
        else
        {
            await UnsubscribeFromLogs();
        }

        _forceRender = true;
        await InvokeAsync(StateHasChanged);
    }

    private async Task SubscribeToLogs()
    {
        if (!_isSubscribed)
        {
            await SignalRService.HubConnection.SendAsync("SubscribeToLogs", WorkerId, EngineId);
            _isSubscribed = true;
        }
    }

    private async Task UnsubscribeFromLogs()
    {
        if (_isSubscribed)
        {
            await SignalRService.HubConnection.SendAsync("UnsubscribeFromLogs", WorkerId, EngineId);
            _isSubscribed = false;
        }
    }

    protected override bool ShouldRender()
    {
        _previousSequenceNumber = null;
        if (_forceRender)
        {
            _forceRender = false;
            return true;
        }
        return !_pauseRendering;
    }

    private async void DownloadLogs()
    {
        var logContent = new System.Text.StringBuilder();
        logContent.AppendLine($"EngineId: {EngineId}, WorkerId: {WorkerId}");
        logContent.AppendLine("Timestamp,LogLevel,Message");

        foreach (var logEntry in LogMessages)
        {
            logContent.AppendLine($"{logEntry.Timestamp},{logEntry.LogLevel},{logEntry.Message}");
        }

        var logFileName = $"logs_{WorkerId}_{DateTime.UtcNow:yyyyMMdd_HHmmss}.txt";
        await TriggerFileDownload(logFileName, logContent.ToString());
    }

    private async Task TriggerFileDownload(string fileName, string content)
    {
        var bytes = System.Text.Encoding.UTF8.GetBytes(content);
        var base64 = Convert.ToBase64String(bytes);
        var fileUrl = $"data:text/plain;base64,{base64}";
        await JsRuntime.InvokeVoidAsync("triggerFileDownload", fileName, fileUrl);
    }
}