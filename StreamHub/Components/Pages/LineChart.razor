@using Common.Models
@using Microsoft.AspNetCore.SignalR.Client
@using StreamHub.Services
@inject IJSRuntime JsRuntime
@inject BlazorSignalRService SignalRService


<h3>Line Chart for Engine @EngineId</h3>

<canvas id="@GetCanvasId()" width="400" height="200"></canvas>

@code {
    [Parameter] public string? EngineId { get; set; }
    [Parameter] public Metric? LastMetric { get; set; }  // Modtag LastMetric som parameter

    private IJSObjectReference? _chart;

    private long[] _timePoints = new long[30];
    private double[] _cpuUsage = new double[30];
    private double[] _netRx = new double[30];
    private double[] _netTx = new double[30];

    
    protected override async Task OnInitializedAsync()
    {
        Console.WriteLine($"Initializing chart for engine {EngineId}");
        SignalRService.HubConnection.On<Metric>("UpdateMetric", async (_) =>
        {
            Console.WriteLine($"RENDERERERE  Received metric for engine {EngineId}");
            
            if (LastMetric != null)
            {
                // Opdater grafen med de nyeste metrics når de kommer ind som parameter
                Console.WriteLine($"Updating chart for engine {EngineId}");
                Console.WriteLine($"CPU: {LastMetric.CPUUsage}, Process CPU: {LastMetric.CurrentProcessCpuUsage}");
                await UpdateChartData(LastMetric.CPUUsage, LastMetric.CurrentProcessCpuUsage, LastMetric.PerCoreCpuUsage[0]);
            }
            
        });

    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            Console.WriteLine($"First render for engine {EngineId}");
            // Simuleret startdata
            for (int i = 0; i < 30; i++)
            {
                _timePoints[29 - i] = DateTimeOffset.UtcNow.AddSeconds(i * -10).ToUnixTimeMilliseconds(); // Ældste data først, så det nyeste til sidst
                _cpuUsage[29 - i] = Random.Shared.NextDouble() * 5;
                _netRx[29 - i] = Random.Shared.NextDouble() * 13;
                _netTx[29 - i] = Random.Shared.NextDouble() * 4;
            }


            var initialData = new
            {
                labels = _timePoints,
                cpuData = _cpuUsage,
                rxData = _netRx,
                txData = _netTx
            };

            // Initier grafen med startdata
            _chart = await JsRuntime.InvokeAsync<IJSObjectReference>("chartInterop.createLineChart", GetCanvasId(), initialData);
        }
    }

    private async Task UpdateChartData(double newCpu, double newRx, double newTx)
    {
        var newTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();  // UNIX timestamp in milliseconds

        // debug with time
        Console.WriteLine($"Updating chart for engine {EngineId} at {newTime}");
        await JsRuntime.InvokeVoidAsync("chartInterop.updateLineChart", _chart, newTime, newCpu, newRx, newTx);
    }
    

    private string GetCanvasId() => $"cpuChart-{EngineId}";
}
