@using Common.Models
@using Microsoft.AspNetCore.SignalR.Client
@using StreamHub.Services
@inject IJSRuntime JsRuntime
@inject BlazorSignalRService SignalRService
@implements IDisposable


<h3>Line Chart for Engine @EngineId</h3>

<canvas id="@GetCanvasId()" width="400" height="200"></canvas>

@code {
    [Parameter] public string? EngineId { get; set; }
    [Parameter] public Metric? LastMetric { get; set; }  // Modtag LastMetric som parameter

    private IJSObjectReference? _chart;

    private long[] _timePoints = new long[30];
    private double[] _cpuUsage = new double[30];
    private double[] _netRx = new double[30];
    private double[] _netTx = new double[30];
    
    protected override async Task OnInitializedAsync()
    {
        Console.WriteLine($"Initializing Historic Line chart for engine {EngineId}");
        SignalRService.HubConnection.On<Metric>("UpdateMetric", async (metric) =>
        {
            if (metric.EngineId.ToString() == EngineId)
            {
                Console.WriteLine($"Updating Historic chart for engine {EngineId}");
                if (LastMetric != null)
                {
                    var metricData = new MetricData
                    {
                        Timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds(),
                        CPUUsage = LastMetric.CPUUsage,
                        RxUsagePercent = LastMetric.RxUsagePercent,
                        TxUsagePercent = LastMetric.TxUsagePercent,
                        RxMbps = LastMetric.RxMbps,
                        TxMbps = LastMetric.TxMbps
                    };
                    Console.WriteLine($"KUKUK Updating chart for engine {EngineId}");
                    await UpdateChartData(metricData);
                }
            }
        });
    }

    public void Dispose()
    {
        Console.WriteLine($"Disposing Historic Line chart for engine {EngineId}");
        SignalRService.HubConnection.Remove("UpdateMetric");
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            Console.WriteLine($"First render for engine {EngineId}");

            var initialMetrics = new List<MetricData>();

            // Generer simuleret startdata i omvendt rækkefølge
            for (int i = 29; i >= 0; i--)
            {
                initialMetrics.Add(new MetricData
                {
                    Timestamp = DateTimeOffset.UtcNow.AddSeconds(i * -10).ToUnixTimeMilliseconds(),
                    CPUUsage = Random.Shared.NextDouble() * 5,
                    RxUsagePercent = Random.Shared.NextDouble() * 13,
                    TxUsagePercent = Random.Shared.NextDouble() * 4,
                    RxMbps = Random.Shared.NextDouble() * 50, // Simuleret Mbps værdi
                    TxMbps = Random.Shared.NextDouble() * 20  // Simuleret Mbps værdi
                });
            }

            // Alternativ løsning: Sortér listen efter Timestamp for at sikre korrekt rækkefølge
            // initialMetrics = initialMetrics.OrderBy(m => m.Timestamp).ToList();

            var initialData = new
            {
                labels = initialMetrics.Select(m => m.Timestamp).ToArray(),
                cpuData = initialMetrics.Select(m => m.CPUUsage).ToArray(),
                rxData = initialMetrics.Select(m => m.RxUsagePercent).ToArray(),
                txData = initialMetrics.Select(m => m.TxUsagePercent).ToArray(),
                metricData = initialMetrics.ToArray() // Inkluder hele MetricData for tooltips
            };

            // Initier grafen med startdata
            _chart = await JsRuntime.InvokeAsync<IJSObjectReference>("chartInterop.createLineChart", GetCanvasId(), initialData);
        }
    }


    private async Task UpdateChartData(MetricData newMetricData)
    {
        Console.WriteLine($"invoke {EngineId}");
    
        if (_chart != null) // Sørg for, at grafen er initialiseret
        {
            var serializedData = System.Text.Json.JsonSerializer.Serialize(newMetricData);
            await JsRuntime.InvokeVoidAsync("chartInterop.updateLineChart", _chart, serializedData);
        }
    }

    
    private string GetCanvasId() => $"cpuChart-{EngineId}";
    
    
    public class MetricData
    {
        public long Timestamp { get; set; }
        public double CPUUsage { get; set; }
        public double RxUsagePercent { get; set; }
        public double TxUsagePercent { get; set; }
        public double RxMbps { get; set; }
        public double TxMbps { get; set; }
    }
    
}
