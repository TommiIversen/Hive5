@inject IJSRuntime JsRuntime
@inject BlazorSignalRService SignalRService
@using Common.Models
@using Microsoft.AspNetCore.SignalR.Client
@using StreamHub.Services
@implements IDisposable

<canvas id="@GetCanvasId()" width="400" height="150"></canvas>

@code {
    [Parameter] public Guid EngineId { get; set; }

    private IJSObjectReference? _chart;
    private readonly List<string> _coreNames = new();

    protected override async Task OnInitializedAsync()
    {
        // Abonner på SignalR-opdateringer
        SignalRService.HubConnection.On<Metric>("UpdateMetric", async (metric) =>
        {
            if (metric.EngineId == EngineId)
            {
                // Hvis der er nye data, opdater grafen
                await UpdateChart(metric.PerCoreCpuUsage);

                // Hvis det er første gang, der modtages data, opret labels for CPU-kerner
                if (_coreNames.Count == 0 && metric.PerCoreCpuUsage.Count > 0)
                {
                    for (int i = 0; i < metric.PerCoreCpuUsage.Count; i++)
                    {
                        _coreNames.Add($"C-{i}");
                    }

                    // Opret grafen med de første modtagne data
                    _chart = await JsRuntime.InvokeAsync<IJSObjectReference>("barChartInterop.createBarChart", GetCanvasId(), _coreNames, metric.PerCoreCpuUsage);
                }
            }
        });
    }

    public void Dispose()
    {
        Console.WriteLine($"Disposing Bar CPU chart for engine {EngineId}");
        //SignalRService.HubConnection.Remove("UpdateMetric");
    }

    private async Task UpdateChart(List<double> updatedCoreUsage)
    {
        if (_chart != null)
        {
            await JsRuntime.InvokeVoidAsync("barChartInterop.updateBarChart", _chart, updatedCoreUsage);
        }
    }

    private string GetCanvasId() => $"cpuBarChart-{EngineId}";
}